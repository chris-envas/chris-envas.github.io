<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="keywords" content="前端">
<meta property="og:type" content="article">
<meta property="og:title" content="TypeScript初窥门径">
<meta property="og:url" content="http://yoursite.com/2019/11/30/TypeScript初窥门径/index.html">
<meta property="og:site_name" content="锦衣无涯">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://s2.ax1x.com/2020/01/18/19SfY9.md.png">
<meta property="og:updated_time" content="2020-01-18T13:03:08.877Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TypeScript初窥门径">
<meta name="twitter:image" content="https://s2.ax1x.com/2020/01/18/19SfY9.md.png">






  <link rel="canonical" href="http://yoursite.com/2019/11/30/TypeScript初窥门径/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>TypeScript初窥门径 | 锦衣无涯</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">
<link rel="stylesheet" href="/music/APlayer.min.css">
<div id="aplayer"></div>
<script type="text/javascript" src="/music/APlayer.min.js"></script>
<script type="text/javascript" src="/music/music.js"></script>

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">锦衣无涯</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">你只有拼尽全力，才能看起来毫不费力</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/30/TypeScript初窥门径/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="罗锦旭">
      <meta itemprop="description" content="记录学习过程是琐碎且费力的，但知识的留存会比以往更为长久">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="锦衣无涯">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">TypeScript初窥门径
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-30 22:14:42" itemprop="dateCreated datePublished" datetime="2019-11-30T22:14:42+08:00">2019-11-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-18 21:03:08" itemprop="dateModified" datetime="2020-01-18T21:03:08+08:00">2020-01-18</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="https://s2.ax1x.com/2020/01/18/19SfY9.md.png" alt=""></p>
<a id="more"></a>
<p>0202年，我开始学习<strong>TypeScript</strong>,本文基于官方示例及网友资料提炼而成，文中含有不少官方示例，但绝非简单地复制粘贴，所有示例均经反复验证或个人提炼，旨在帮助你更好的掌握<strong>TypeScript</strong>，学习的过程中，最大的感受就是<strong>TypeScript</strong>超强且繁琐的类型判断系统会让你感觉十分难受，至少对于我来说是如此，总之万事开头难，只能坚持下去才有收获！</p>
<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><blockquote>
<p>TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用 </p>
</blockquote>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>布尔值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isDone: boolean = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>数字</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decLiteral:number = <span class="number">20</span></span><br><span class="line"><span class="keyword">let</span> hexLiteral:number = <span class="number">0x14</span></span><br><span class="line"><span class="keyword">let</span> binaryLiteral:number = <span class="number">0b10100</span></span><br><span class="line"><span class="keyword">let</span> octalLiteral:number = <span class="number">0o24</span></span><br></pre></td></tr></table></figure>
<p>字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name:string = <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure>
<p>数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list:number[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>元组</p>
<blockquote>
<p>元组允许表示一个已知的数量和类型的数组</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x:[string,number]</span><br><span class="line">x = [<span class="string">'hello world'</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>枚举</p>
<blockquote>
<p><code>enum</code>类型是对JavaScript标准数据类型的一个补充 </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> SunName:string = Days[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>以上代码经过ts编译后为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Days;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Days</span>) </span>&#123;</span><br><span class="line">    Days[Days[<span class="string">"Sun"</span>] = <span class="number">0</span>] = <span class="string">"Sun"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Mon"</span>] = <span class="number">1</span>] = <span class="string">"Mon"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Tue"</span>] = <span class="number">2</span>] = <span class="string">"Tue"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Wed"</span>] = <span class="number">3</span>] = <span class="string">"Wed"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Thu"</span>] = <span class="number">4</span>] = <span class="string">"Thu"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Fri"</span>] = <span class="number">5</span>] = <span class="string">"Fri"</span>;</span><br><span class="line">    Days[Days[<span class="string">"Sat"</span>] = <span class="number">6</span>] = <span class="string">"Sat"</span>;</span><br><span class="line">&#125;)(Days || (Days = &#123;&#125;));</span><br><span class="line"><span class="keyword">var</span> SunName = Days[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>通过枚举，我们可以为一组数据赋予更好的映射方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red = <span class="number">1</span>, Green, Blue&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green; <span class="comment">//2</span></span><br><span class="line"><span class="keyword">let</span> r: Color = Color.Red; <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>null和undefined</p>
<blockquote>
<p>在typescript中，null与undefined也是有效的类型，实际用处并不大</p>
<p>启用严格空检查模式时 –strictNullChecks，若无使用联合类型，将报错 ，简单的说就是，在严格模式下，我们将无法对一个变量进行null或undefined的赋值</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num:number|<span class="literal">null</span>|<span class="literal">undefined</span></span><br><span class="line">num = <span class="number">1</span></span><br><span class="line">num = <span class="literal">null</span> <span class="comment">//yes</span></span><br><span class="line">num = <span class="literal">undefined</span> <span class="comment">//yes</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x:number</span><br><span class="line">num = <span class="number">1</span></span><br><span class="line">num = <span class="literal">null</span> <span class="comment">//no</span></span><br><span class="line">num = <span class="literal">undefined</span> <span class="comment">//no</span></span><br></pre></td></tr></table></figure>
<p>never</p>
<blockquote>
<p>never类型是用于表示那些用不存在的值的类型，下面是一些示例</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message:string</span>):<span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 推断的返回值类型为never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> err(<span class="string">'failed'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//死循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>any</p>
<blockquote>
<p><code>any</code>类型就像它本身代表的含义一样，在我看来，即是允许任何类型的赋值</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a:any = <span class="number">4</span></span><br><span class="line">a = <span class="string">'hello'</span> </span><br><span class="line">a = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//整个不同类型数据</span></span><br><span class="line"><span class="keyword">let</span> list:any[] = [<span class="number">1</span>,<span class="literal">true</span>,<span class="string">'hello'</span>]</span><br></pre></td></tr></table></figure>
<p>void</p>
<blockquote>
<p><code>void</code>类型与<code>any</code>恰恰相反，它表示无任何类型</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">warn</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'no any thing'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值只能null或undefined</span></span><br><span class="line"><span class="keyword">let</span> unval: <span class="keyword">void</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>object</p>
<blockquote>
<p><code>object</code>表示非原始类型</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">o: object | null</span>): <span class="title">void</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params">&#123; prop: <span class="number">0</span> &#125;</span>); // <span class="title">OK</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params">null</span>); // <span class="title">OK</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params"><span class="number">42</span></span>); // <span class="title">Error</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params"><span class="string">"string"</span></span>); // <span class="title">Error</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params">false</span>); // <span class="title">Error</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params">undefined</span>); // <span class="title">Error</span></span></span><br></pre></td></tr></table></figure>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>类型断言</p>
<blockquote>
<p>类型断言应用于，你比typescript编译器更了解这个类型时覆盖它的判断 </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">obj.num = <span class="number">3</span> <span class="comment">//Error</span></span><br><span class="line">obj.string = <span class="string">'hello'</span> <span class="comment">//Error</span></span><br></pre></td></tr></table></figure>
<p>typescript编译器认为这个对象不存在这个两个属性，提示报错， 通过类型断言，覆盖它的判断</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Foo &#123;</span><br><span class="line">    num: number,</span><br><span class="line">    string: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125; <span class="keyword">as</span> Foo</span><br><span class="line">obj.num = <span class="number">3</span> </span><br><span class="line">obj.string = <span class="string">'hello'</span></span><br></pre></td></tr></table></figure>
<p>断言重写，除了覆盖掉编译器的判断，还会覆盖你之前设置的判断，如覆盖只读属性</p>
<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><blockquote>
<p>尽量抛弃var,使用let</p>
</blockquote>
<p>三个变量声明，不解释</p>
<ul>
<li>var</li>
<li>let</li>
<li>const</li>
</ul>
<h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><blockquote>
<p>解构部分与ES6+大体是相同的，也不过是增加了类型判断</p>
</blockquote>
<p><strong>数组解构</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[f,s]:[number,number]</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(f,s)</span><br><span class="line">&#125;</span><br><span class="line">f(input)</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展运算符</span></span><br><span class="line"><span class="keyword">let</span> [f,...s] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="built_in">console</span>.log(f,s)</span><br></pre></td></tr></table></figure>
<p><strong>对象解构</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    c: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展运算符</span></span><br><span class="line"><span class="keyword">let</span> &#123;a,...other&#125; = obj</span><br><span class="line"><span class="built_in">console</span>.log(other)</span><br></pre></td></tr></table></figure>
<p><strong>展开</strong></p>
<blockquote>
<p>对象展开是从左到右的覆盖，注意顺序</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> man = &#123;</span><br><span class="line">    name: <span class="string">'cc'</span>,</span><br><span class="line">    age: <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> add = &#123;...man,<span class="attr">name</span>:<span class="string">'xx'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add) <span class="comment">//&#123; name: 'xx', age: 22 &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><blockquote>
<p>官网指出，typescript的接口是对值所具有的结构进行类型检查，它有时也被称为“ 鸭式辨型法 ”</p>
<p>这个奇怪的名字，源于美国作家 James Whitecomb Riley 的名言： “像鸭子一样走路并且嘎嘎叫的就叫鸭子 “</p>
</blockquote>
<p>原生之鸭式辨型法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建接口类</span></span><br><span class="line"><span class="keyword">let</span> Interface = <span class="function"><span class="keyword">function</span>(<span class="params">name,methods</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.methods = methods</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检验规范</span></span><br><span class="line">Interface.prototype.ensureImplements = <span class="function"><span class="keyword">function</span>(<span class="params">obj,interface</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> canNotMethods = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;interface.methods.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!interface.method[i] || <span class="keyword">typeof</span> obj[interface.method[i] !== <span class="function"><span class="keyword">function</span>) </span>&#123;</span><br><span class="line">            canNotMethods.push(interface.method[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(canNotMethods.length)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(obj.name+<span class="string">'实例对象没有实现'</span>+interface.name+<span class="string">'接口'</span>)  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(obj.name+<span class="string">'实例对象已经实现'</span>+interface.name+<span class="string">'接口'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里定义鸭的规范类</span></span><br><span class="line"><span class="keyword">let</span> Duck = <span class="keyword">new</span> Interface(<span class="string">"Duck"</span>,&#123;<span class="string">'swim'</span>,<span class="string">'cryy'</span>,<span class="string">'foots'</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建duck1类</span></span><br><span class="line"><span class="keyword">let</span> duck1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">this</span>.name = <span class="string">'duck1'</span>&#125;</span><br><span class="line">duck1.prototype = &#123;</span><br><span class="line">    <span class="string">'swim'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    <span class="string">'cry'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    <span class="string">'foots'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;,   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建duck2类</span></span><br><span class="line"><span class="keyword">let</span> duck2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">this</span>.name = <span class="string">'duck1'</span>&#125;</span><br><span class="line">duck2.prototype = &#123;</span><br><span class="line">    <span class="string">'cry'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    <span class="string">'foots'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;,   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化并检测</span></span><br><span class="line"><span class="keyword">let</span> new_duck1 = <span class="keyword">new</span> duck1()</span><br><span class="line"><span class="keyword">let</span> new_duck2 = <span class="keyword">new</span> duck2()</span><br><span class="line">Interface.ensureImplements(new_duck1, Duck)</span><br><span class="line">Interface.ensureImplements(new_duck2, Duck)</span><br></pre></td></tr></table></figure>
<p>上述代码中，通过创建接口类<code>Interface</code>来保存实例类的各项信息，接着，我们定义了一个鸭子类<code>Duck</code>，在我们的认知中，会游泳(swim)、呱呱叫(cry)、有两只脚(foots)的就是鸭子，紧接着，我们创建了两个类分别为<code>duck1</code>和<code>duck2</code>，并在原型中定义好该类的属性方法，创建好各自的实例。</p>
<p>通过<code>Interface.ensureImplements</code>进行检验，<code>duck1</code>和<code>duck2</code>到底是不是真的鸭的类。</p>
<p>很明显<code>duck1</code>是鸭的类，<code>duck2</code>因为缺少了游泳(swim)这一属性，我们判定为不是鸭子，它还可能是其他事物</p>
<p>所谓”鸭式辨型法“,即是检查对象是否拥有你所定义好的接口的所有方法，接口要做的就是准确记住所有定义好的方法名称，而不需去判断实现的方法是否正确，说白了，就是规范代码的一个规则。</p>
<p>typescript接口实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface LabelledValue &#123;</span><br><span class="line">  label: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">labelledObj: LabelledValue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(labelledObj.label);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123;<span class="attr">size</span>: <span class="number">10</span>, <span class="attr">label</span>: <span class="string">"Size 10 Object"</span>&#125;;</span><br><span class="line">printLabel(myObj)</span><br></pre></td></tr></table></figure>
<p><strong>可选属性</strong></p>
<blockquote>
<p>常规定义的接口的每个属性不一定我们每次都会用到，使用可选属性在接口定义的属性后增加？符号，可解决这个问题</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    sex?: string,</span><br><span class="line">    age?: number,</span><br><span class="line">    height?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span> (<span class="params">config: Person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> man = &#123;<span class="attr">sex</span>:<span class="string">'man'</span>,<span class="attr">age</span>:<span class="number">22</span>&#125;</span><br><span class="line">    <span class="keyword">if</span>(config.sex) &#123;</span><br><span class="line">        man.sex = config.sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(config.age) &#123;</span><br><span class="line">        man.age = config.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> man;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = createPerson(&#123;<span class="attr">sex</span>:<span class="string">'man'</span>,<span class="attr">age</span>:<span class="number">25</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(p1) <span class="comment">// &#123; sex: 'man', age: 25 &#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>额外的属性检查</strong></p>
<p>以之前代码为例，假设我们在传递参数的时候，使用了额外的属性，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error: 'mex' not expected in type 'Person'</span></span><br><span class="line"><span class="keyword">let</span> p2 = createPerson(&#123;<span class="attr">mex</span>:<span class="string">'man'</span>,<span class="attr">age</span>:<span class="number">25</span>&#125;) ;</span><br></pre></td></tr></table></figure>
<p><code>mex</code>并不在我们定义的接口属性中，必然报错，想要代码通过，我们可以使用类型断言</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p2 = createPerson(&#123;<span class="attr">mex</span>:<span class="string">'xxx'</span>,<span class="attr">age</span>:<span class="number">25</span>&#125; <span class="keyword">as</span> Person) <span class="comment">// &#123; sex: 'man', age: 25 &#125;</span></span><br></pre></td></tr></table></figure>
<p> 然而，最佳的方式是能够添加一个字符串索引签名 <code>propName</code>，意味着，除了已定义的<code>sex</code>、<code>age</code>、<code>height</code>三个属性，其他属性可选任意类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    sex?: string,</span><br><span class="line">    age?: number,</span><br><span class="line">    height?: number,</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = createPerson(&#123;<span class="attr">mex</span>:<span class="string">'xxx'</span>,<span class="attr">age</span>:<span class="number">25</span>&#125;) <span class="comment">// &#123; sex: 'man', age: 25 &#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>只读属性</strong></p>
<blockquote>
<p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 <code>readonly</code>来指定只读属性</p>
<p><code>readonly</code>的作用与<code>const</code>一样，定义后，无法再修改,只不过一个作用于属性，一个作用于变量</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">    readonly x: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1: Point = &#123;<span class="attr">x</span>:<span class="number">10</span>&#125;;</span><br><span class="line">p1.x = <span class="number">5</span>; <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p><strong>只读数组</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;number&gt; = a;</span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// error!</span></span><br><span class="line">ro.push(<span class="number">5</span>); <span class="comment">// error!</span></span><br><span class="line">ro.length = <span class="number">100</span>; <span class="comment">// error!</span></span><br><span class="line">a = ro; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>
<p>想要使<strong>a = ro</strong>,我们需要对ro进行类型断言，使得之前的只读属性被覆盖即可</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = ro <span class="keyword">as</span> number[] <span class="comment">//yes</span></span><br></pre></td></tr></table></figure>
<p><strong>函数类型接口</strong> </p>
<blockquote>
<p>用于描述函数规范的接口</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Func &#123;</span><br><span class="line">    (source:string,<span class="attr">subString</span>:string): boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的函数接口定义了传入的参数类型及函数的返回值类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn: Func</span><br><span class="line">fn = <span class="function"><span class="keyword">function</span>(<span class="params">source: string, subString: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = source.search(subString);</span><br><span class="line">    <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可索引类型</strong></p>
<blockquote>
<p>用于描述数组规范的接口</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface StringArray &#123;</span><br><span class="line">    [index: number]: string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr: StringArray;</span><br><span class="line">arr = [<span class="string">'hi'</span>,<span class="string">'bye'</span>];</span><br><span class="line"><span class="keyword">let</span> str: string = arr[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>typescript支持两种索引签名,分别是数字和字符串</p>
<p>官网提到在在同时使用两种类型索引时，“数字索引的返回值必须是字符串索引返回值类型的子类型”  </p>
<p>话不多说，直接跑官网的实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    name: <span class="built_in">Number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    breed: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!</span></span><br><span class="line">interface NotOkay &#123;</span><br><span class="line">    [x: number]: Animal</span><br><span class="line">    [x: string]: Dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码数字索引的返回值<code>Animal</code>很明显不是字符串索引返回值<code>Dog</code>的子类型，索引这里报了个错</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数字索引类型Animal不能分配给字符串索引类型Dog</span></span><br><span class="line">Numeric index type <span class="string">'Animal'</span> is not assignable to string index type <span class="string">'Dog'</span></span><br></pre></td></tr></table></figure>
<p>稍作修改，即可编译通过</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface NotOkay &#123;</span><br><span class="line">    [x: number]: Dog</span><br><span class="line">    [x: string]: Animal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>类类型</strong></p>
<blockquote>
<p>“与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约” </p>
<p>类的类型分为静态部分和实例部分，类通过implements去实现一个接口时，类无法实现静态部分的接口，但可以实现实例部分的接口</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface ColorInterface &#123;</span><br><span class="line">    color: string</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> <span class="title">implements</span> <span class="title">ColorInterface</span> </span>&#123;</span><br><span class="line">    color: string</span><br><span class="line">    <span class="keyword">constructor</span> (num:number) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口描述了类的公共部分</p>
<p><code>color</code>属于实例部分，<code>constructor</code>则是静态部分，下面我们尝试取通过接口描述静态部分</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface ColorConstructor &#123;</span><br><span class="line">    <span class="keyword">new</span> (num:number)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> <span class="title">implements</span> <span class="title">ColorConstructor</span> </span>&#123;</span><br><span class="line">    color: string</span><br><span class="line">    <span class="keyword">constructor</span> (num:number) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译报错</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Color错误的实现接口ColorConstructor</span></span><br><span class="line">Class <span class="string">'Color'</span> incorrectly implements interface <span class="string">'ColorConstructor'</span></span><br></pre></td></tr></table></figure>
<p>从这里可以得知，当我们使用类去实现(implements)接口时，只会对其实例部分进行类型检查，<code>constructor</code>静态部分，不在检查的范围</p>
<p>那么应该如何取操作静态类型部分？官网给出了解决的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">interface ColorInterface &#123;</span><br><span class="line">    draw()</span><br><span class="line">&#125;</span><br><span class="line">interface ColorConstructor &#123;</span><br><span class="line">    <span class="keyword">new</span> (num:number)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createColor</span> (<span class="params">ctor:ColorConstructor,num:number</span>):<span class="title">ColorInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ctor(num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">implements</span> <span class="title">ColorInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(num:number)&#123;&#125;</span><br><span class="line">    draw()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'A draw'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="title">implements</span> <span class="title">ColorInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(num:number)&#123;&#125;</span><br><span class="line">    draw()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'B draw'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = createColor(A, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> b1 = createColor(B, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a1,b1)</span><br></pre></td></tr></table></figure>
<p>上述代码通过创建构造函数<code>createColor</code>并将类<code>A</code>、<code>B</code>作为其第一参数传入，而第一参数是<code>ColorConstructor</code>类型，故而会去检查是否符合构造函数类型签名</p>
<p><strong>继承接口</strong></p>
<blockquote>
<p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里 </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface Shape &#123;</span><br><span class="line">    color: string</span><br><span class="line">&#125;</span><br><span class="line">interface Penwidth &#123;</span><br><span class="line">    penwidth: number</span><br><span class="line">&#125;</span><br><span class="line">interface Square extends Shape,Penwidth &#123;</span><br><span class="line">    slideLength: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = <span class="xml"><span class="tag">&lt;<span class="name">Square</span>&gt;</span>&#123;&#125;</span></span><br><span class="line"><span class="xml">square.color = 'red'</span></span><br><span class="line"><span class="xml">square.penwidth = 6</span></span><br><span class="line"><span class="xml">square.slideLength = 3</span></span><br></pre></td></tr></table></figure>
<p>接口还可以同时继承多个，只需以<code>,</code>分隔即可</p>
<p><strong>混合类型</strong></p>
<blockquote>
<p>先前我们提过，接口能够描述JavaScript里丰富的类型。 因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型</p>
</blockquote>
<p>我们希望一个接口可以同时描述函数和对象使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Counter &#123;</span><br><span class="line">    (start: number): string <span class="comment">//函数 返回字符串类型</span></span><br><span class="line">    interval: number <span class="comment">//属性 数字类型</span></span><br><span class="line">    reset(): <span class="keyword">void</span> <span class="comment">//属性 无返回值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> counter = <span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span>function (start: number) &#123; &#125;;</span></span><br><span class="line"><span class="xml">    counter.interval = 123;</span></span><br><span class="line"><span class="xml">    counter.reset = function () &#123; &#125;;</span></span><br><span class="line"><span class="xml">    return counter;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">let c = getCounter();</span></span><br><span class="line"><span class="xml">c(10);</span></span><br><span class="line"><span class="xml">c.reset();</span></span><br><span class="line"><span class="xml">c.interval = 5.0;</span></span><br></pre></td></tr></table></figure>
<p><strong>接口继承类</strong></p>
<blockquote>
<p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样 </p>
<p>接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement） </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Control</span> </span>&#123;</span><br><span class="line">    private state: any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface SelectabControl extends Control &#123;</span><br><span class="line">    select(): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">Control</span> <span class="title">implements</span> <span class="title">Control</span> </span>&#123;</span><br><span class="line">    select() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBox</span> <span class="keyword">extends</span> <span class="title">Control</span> </span>&#123;</span><br><span class="line">    select() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Image缺乏state属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span> <span class="title">implements</span> <span class="title">SelectableControl</span>  </span>&#123;</span><br><span class="line">    select() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面例子中，<code>SelectabControl</code> 接口继承了<code>Control</code>,所以<code>SelectabControl</code>包含了<code>Control</code>的所有成员，包括私有成员<code>state</code>,同时因为<code>state</code>是私有的，导致<code>SelectabControl</code> 接口只能为<code>Control</code>或其子类才能实现它</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><blockquote>
<p>关于类的基本使用，我想不需赘述，有趣的部分应该是相比于原生,typescript在类的使用上，有怎样的变化？</p>
</blockquote>
<p><strong>公共，私有与受保护的修饰符</strong></p>
<p>默认为 <code>public</code></p>
<p>在typescript中，所有成员默认为public，当然你也可以重新标记</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    public name: string</span><br><span class="line">    public <span class="keyword">constructor</span>(name: string) &#123;<span class="keyword">this</span>.name = name&#125;</span><br><span class="line">	public say(name: string) &#123;<span class="built_in">console</span>.log(<span class="string">`hi <span class="subst">$&#123;name&#125;</span>,I am <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理解 <code>private</code></p>
<p>当成员被标记为private时，它不能在声明类的外部访问</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    public name: string</span><br><span class="line">    private age: string</span><br><span class="line">    public <span class="keyword">constructor</span>(name: string) &#123;<span class="keyword">this</span>.name = name&#125;</span><br><span class="line">	public say(name: string) &#123;<span class="built_in">console</span>.log(<span class="string">`hi <span class="subst">$&#123;name&#125;</span>,I am <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'cc'</span>)</span><br><span class="line">p1.say(<span class="string">'lili'</span>)</span><br><span class="line"><span class="comment">//Property 'age' is private and only accessible within class 'Person'</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.age)</span><br></pre></td></tr></table></figure>
<p>理解<code>protected</code></p>
<blockquote>
<p><code>protected</code>修饰符与 <code>private</code>修饰符的行为很相似，但有一点不同， <code>protected</code>成员在派生类中仍然可以访问 </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    public name: string</span><br><span class="line">    protected age: string</span><br><span class="line">    protected <span class="keyword">constructor</span>(name: string,age: string) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">	public say(name: string) &#123;<span class="built_in">console</span>.log(<span class="string">`hi <span class="subst">$&#123;name&#125;</span>,I am <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name: string,age: string) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name,age)</span><br><span class="line">        <span class="keyword">this</span>.sayinfo()</span><br><span class="line">    &#125;</span><br><span class="line">    public sayinfo() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> is <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span> years old`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom = <span class="keyword">new</span> Man(<span class="string">'tom'</span>,<span class="string">'23'</span>) <span class="comment">// tom is 23 years old</span></span><br><span class="line"><span class="keyword">let</span> krash = <span class="keyword">new</span> Person(<span class="string">'krash'</span>,<span class="string">'22'</span>) <span class="comment">// Person构造函数是受保护的</span></span><br></pre></td></tr></table></figure>
<p>readonly修饰符</p>
<blockquote>
<p>设置只读属性，只读属性必须再声明时或构造函数里被初始化</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Octopus</span> </span>&#123;</span><br><span class="line">    readonly name: string</span><br><span class="line">    <span class="keyword">constructor</span>(name: string) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> choo = <span class="keyword">new</span> Octopus(<span class="string">'choo'</span>)</span><br><span class="line">t1.name = <span class="string">'kiki'</span> <span class="comment">// Cannot find name 't1'</span></span><br></pre></td></tr></table></figure>
<p><strong>参数属性</strong></p>
<blockquote>
<p>在函数中，将参数加上修饰符，这一做法，可以迅速完成赋值操作</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Octopus</span> </span>&#123; </span><br><span class="line">    <span class="comment">//参数属性 自动完成对name属性的声明、修饰符及赋值的过程 提高编程效率 缺点是不够直观</span></span><br><span class="line">    <span class="keyword">constructor</span>( readonly name: string) &#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> choo = <span class="keyword">new</span> Octopus(<span class="string">'choo'</span>) <span class="comment">// choo</span></span><br></pre></td></tr></table></figure>
<p><strong>存取器</strong></p>
<blockquote>
<p>“TypeScript支持通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问” </p>
<p>这一点，于ES6一致</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>  </span>&#123;</span><br><span class="line">    private _fullName: string</span><br><span class="line">    get fullName():string &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._fullName</span><br><span class="line">    &#125;</span><br><span class="line">    set fullName(name:string) &#123;</span><br><span class="line">        <span class="keyword">if</span>(name&amp;&amp;name==<span class="string">'choo'</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>._fullName = name</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">'Error: Unauthorized update of employee'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee =  <span class="keyword">new</span> Employee()</span><br><span class="line">employee.fullName = <span class="string">'choo'</span></span><br><span class="line"><span class="built_in">console</span>.log(employee.fullName)</span><br></pre></td></tr></table></figure>
<p>这里发现一个报错，存取器需要定义目标再ES5之上</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accessors are only available when targeting ECMAScript 5 and higher</span><br></pre></td></tr></table></figure>
<p>使用es5以上的编译目标方可通过</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --target es5 <span class="class"><span class="keyword">class</span>.<span class="title">ts</span></span></span><br></pre></td></tr></table></figure>
<p><strong>静态属性&amp;&amp;静态方法</strong></p>
<blockquote>
<p>在类中，使用static关键字定义的属性为静态属性，静态属性的访问，都需要加上类名，而不是使用this</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grid</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> origin = &#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;</span><br><span class="line">	<span class="keyword">static</span> layout() &#123;<span class="built_in">console</span>.log()&#125;</span><br><span class="line">    calculateDistanceFromOrigin(point: &#123;<span class="attr">x</span>: number; y: number;&#125;) &#123;</span><br><span class="line">        <span class="keyword">let</span> xDist = (point.x - Grid.origin.x)</span><br><span class="line">        <span class="keyword">let</span> yDist = (point.y - Grid.origin.y)</span><br><span class="line">        Grid.layout()</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(xDist * xDist + yDist * yDist) / <span class="keyword">this</span>.scale</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span> (public scale: number) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> grid1 = <span class="keyword">new</span> Grid(<span class="number">1.0</span>)  <span class="comment">// 1x scale</span></span><br><span class="line"><span class="keyword">let</span> grid2 = <span class="keyword">new</span> Grid(<span class="number">5.0</span>)  <span class="comment">// 5x scale</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(grid1.calculateDistanceFromOrigin(&#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">10</span>&#125;))</span><br><span class="line"><span class="built_in">console</span>.log(grid2.calculateDistanceFromOrigin(&#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">10</span>&#125;))</span><br></pre></td></tr></table></figure>
<p><strong>抽象类</strong></p>
<blockquote>
<p>抽象类旨在通过abstract关键字定义的类，抽象方法的语法于接口相似，两者都是定义方法但不包含函数体，且抽象方法必须包含abstract关键字并且可以包含访问修饰符，需要注意的是抽象类无法被直接创建实例，只能对抽象类字类进行实例化创建</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">Deparment</span> </span>&#123;</span><br><span class="line">     <span class="keyword">constructor</span>(public name: string) &#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     printName() &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 定义抽象方法 不包含具体实现</span></span><br><span class="line">     public abstract printMeeting(): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AcountingDeparment</span> <span class="keyword">extends</span> <span class="title">Deparment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">'Accountng and Auditing'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    printMeeting () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Accounting deparment meets each monday at 10am,'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> deparment: Deparment</span><br><span class="line">deparment = <span class="keyword">new</span> AcountingDeparment()</span><br><span class="line">deparment.printMeeting()</span><br><span class="line">deparment.printName()</span><br></pre></td></tr></table></figure>
<p><strong>高级技巧</strong></p>
<p>构造函数</p>
<blockquote>
<p>构造函数包含了这个类所有的静态成员和构造函数，通过 typeof Greeter 取到Greeter类型，获取构造函数，可以对静态属性重新赋值</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gretter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> standardGreeting = <span class="string">'hello !'</span></span><br><span class="line">    <span class="keyword">constructor</span>(public message: string) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    greet() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello'</span> + <span class="keyword">this</span>.message</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gretter: Gretter</span><br><span class="line">gretter = <span class="keyword">new</span> Gretter(<span class="string">'world'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(gretter.greet())</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> greeteMaker: <span class="keyword">typeof</span> Gretter = Gretter</span><br><span class="line">greeteMaker.standardGreeting = <span class="string">'hey !'</span></span><br></pre></td></tr></table></figure>
<p><strong>把类做接口</strong></p>
<p>常规的接口</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typescript</span></span><br><span class="line">interface Point &#123;</span><br><span class="line">    x: number</span><br><span class="line">    y: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Point2D extends Point &#123;</span><br><span class="line">    z: number</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> Point2D: Point2D = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译后代码</span></span><br><span class="line"><span class="keyword">var</span> Point2D = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>类亦可作为接口使用</strong>（不推荐）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">    x: number</span><br><span class="line">    y: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Point2D extends Point &#123;</span><br><span class="line">    z: number</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> Point2D: Point2D = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译后代码</span></span><br><span class="line"><span class="keyword">var</span> Point2D = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> Point = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Point;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="keyword">var</span> Point2D = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>为函数定义类型</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: number, y: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="function"><span class="keyword">function</span> (<span class="params">x: number, y: number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>完整函数类型</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myAdd: <span class="function">(<span class="params">v1: number, v2: number</span>) =&gt;</span> number = <span class="function"><span class="keyword">function</span>(<span class="params">x: number, y: number</span>):<span class="title">number</span> </span>&#123;</span><br><span class="line">    retun x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整参数类型包含两个部分：参数类型和返回值类型，这两个部分是必须的。</p>
<p>为参数指定名字和类型，只要参数类型匹配，并不在乎参数名是否正确，返回值类型，我们可使用（=&gt;）符号指定，如函数没有返回值，必须指定<code>void</code>而不得留空</p>
<p><strong>类型推断</strong></p>
<blockquote>
<p>如果你在赋值语句一边指定了类型但是另一边没有类型，编译器会自动识别出类型</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myAdd: <span class="function">(<span class="params">v1: number, v2: number</span>) =&gt;</span> number = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;<span class="keyword">return</span> x + y&#125;</span><br></pre></td></tr></table></figure>
<p>可选参数和默认参数</p>
<p>typescript的每个参数都是必须的，如果要使该参数为可选的，可使用<code>?</code>符号作为后缀，且可选参数必须在必须参数后面</p>
<p><strong>剩余参数</strong></p>
<p>剩余参数旨在解决参数个数不确定的情况,利用<code>...</code>省略号的名字，且类型判断为数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: string, ...restOfName: string[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">" "</span> + restOfName.join(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employeeName = buildName(<span class="string">"Joseph"</span>, <span class="string">"Samuel"</span>, <span class="string">"Lucas"</span>, <span class="string">"MacKinzie"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>this和箭头函数</strong></p>
<blockquote>
<p>“ 学习如何在JavaScript里正确使用<code>this</code>就好比一场成年礼 “</p>
<p>“ JavaScript里，<code>this</code>的值在函数被调用的时候才会指定。 这是个既强大又灵活的特点 “</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> deck = &#123;</span><br><span class="line">    suits: [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>],</span><br><span class="line">    cards: <span class="built_in">Array</span>(<span class="number">52</span>),</span><br><span class="line">    createCardPicker: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>);</span><br><span class="line">            <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">suit</span>: <span class="keyword">this</span>.suits[pickedSuit], <span class="attr">card</span>: pickedCard % <span class="number">13</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker();</span><br><span class="line"><span class="keyword">let</span> pickedCard = cardPicker();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"card: "</span> + pickedCard.card + <span class="string">" of "</span> + pickedCard.suit);</span><br></pre></td></tr></table></figure>
<p>上述代码报错的原因很简单，<code>cardPicker</code>函数执行时函数上下文为全局作用域，故而它的this指向被绑定到额<code>window</code>上，在严格模式下为<code>undefined</code></p>
<p>如何解决这个问题？也许我们会很轻易的想到<code>apply</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line"><span class="keyword">let</span> pickedCard = cardPicker.apply(deck);</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>但也有，更简单的办法，那就是箭头函数(保留调用时的this)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> deck = &#123;</span><br><span class="line">  	...</span><br><span class="line">    createCardPicker: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>);</span><br><span class="line">            <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">suit</span>: <span class="keyword">this</span>.suits[pickedSuit], <span class="attr">card</span>: pickedCard % <span class="number">13</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>虽然问题解决了，但是这里<code>this</code>的类型是<code>any</code>，如果在编译器选项中设置<code>--noImplicitThis</code>标记，那么<code>this.suits[pickedSuit]</code>会出现报错</p>
<p>因为，这里需要使用接口规范<code>this</code>的类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">interface Card &#123;</span><br><span class="line">    suit: string</span><br><span class="line">    card: number</span><br><span class="line">&#125;</span><br><span class="line">interface Deck &#123;</span><br><span class="line">    suits: string[];</span><br><span class="line">    cards: number[];</span><br><span class="line">    createCardPicker(<span class="keyword">this</span>: Deck): <span class="function"><span class="params">()</span> =&gt;</span> Card</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> deck: Deck = &#123;</span><br><span class="line">    suits: [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>],</span><br><span class="line">    cards: <span class="built_in">Array</span>(<span class="number">52</span>),</span><br><span class="line">    createCardPicker: <span class="function"><span class="keyword">function</span>(<span class="params">this: Deck</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>)</span><br><span class="line">            <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">suit</span>: <span class="keyword">this</span>.suits[pickedSuit], <span class="attr">card</span>: pickedCard % <span class="number">13</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker()</span><br><span class="line"><span class="keyword">let</span> pickedCard = cardPicker()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"card: "</span> + pickedCard.card + <span class="string">" of "</span> + pickedCard.suit)</span><br></pre></td></tr></table></figure>
<p>在函数参数中规定了<code>this: Deck</code>,声明<code>this</code>为<code>Deck</code>类型，而非<code>any</code></p>
<p><strong>this参数在回调函数里</strong></p>
<blockquote>
<p>this参数在回调函数中时，涉及到指向的问题，这里可以用箭头函数（arrow function）来保留原本this的指向，如下所示</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">interface UIElement &#123;</span><br><span class="line">    addClickListener(onclick: <span class="function">(<span class="params"><span class="keyword">this</span>: <span class="keyword">void</span></span>) =&gt;</span> <span class="keyword">void</span>): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    info: string = <span class="string">'this is diffcult'</span>;</span><br><span class="line">    onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'oh!'</span>+<span class="keyword">this</span>.info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uiElement: UIElement = &#123;</span><br><span class="line">    addClickListener (onclick) &#123;</span><br><span class="line">       onclick()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> Handler();</span><br><span class="line">uiElement.addClickListener(h.onclick); <span class="comment">// oh! this is diffcult</span></span><br></pre></td></tr></table></figure>
<p><strong>重载</strong></p>
<blockquote>
<p>在JavaScript中函数根据在不同的参数返回不同类型的数据是很常见的，但是在TypeScript中，要如何在类型系统里进行表示？答案需要用到重载！</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> suits = [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: &#123;suit: string; card: number; &#125;[]</span>): <span class="title">number</span>;</span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">pickCard</span>(<span class="params">x: number</span>): </span>&#123;suit: string; card: number; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Check to see if we're working with an object/array</span></span><br><span class="line">    <span class="comment">// if so, they gave us the deck and we'll pick the card</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"object"</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * x.length);</span><br><span class="line">        <span class="keyword">return</span> pickedCard;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Otherwise just let them pick the card</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"number"</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(x / <span class="number">13</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">suit</span>: suits[pickedSuit], <span class="attr">card</span>: x % <span class="number">13</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDeck = [&#123; <span class="attr">suit</span>: <span class="string">"diamonds"</span>, <span class="attr">card</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">suit</span>: <span class="string">"spades"</span>, <span class="attr">card</span>: <span class="number">10</span> &#125;, &#123; <span class="attr">suit</span>: <span class="string">"hearts"</span>, <span class="attr">card</span>: <span class="number">4</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> pickedCard1 = myDeck[pickCard(myDeck)];</span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard1.card + <span class="string">" of "</span> + pickedCard1.suit);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pickedCard2 = pickCard(<span class="number">15</span>);</span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard2.card + <span class="string">" of "</span> + pickedCard2.suit);</span><br></pre></td></tr></table></figure>
<p>重载后的<code>pickCard</code>函数会在调用时进行正确的类型检测，以上代码声明了两个重载：一个时接收对象另一个接收数字</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><blockquote>
<p>什么是泛型（Generic）? 泛型允许程序在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化的时候作为参数指明类型</p>
</blockquote>
<p>假设现在有一个函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span> (<span class="params">arg: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i1 = identity(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> i2 = identity(<span class="string">'1'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> i1,<span class="keyword">typeof</span> i2) <span class="comment">// number string</span></span><br></pre></td></tr></table></figure>
<p>由于我们设置了<code>any</code>类型，导致同个函数因为传递参数类型的不同，输出了不同的结果，这在某种场景下会给我们带来不必要的麻烦，诚然我们可以在一开始就将其设置为<code>number</code>类型，但是没准，在某一刻，我们又希望该函数又能处理<code>string</code>的需求，故此，我们迫切需要这样一种能力，当你在需要什么的时候，你可以动态的修改参数的接收类型，而这，便是泛型，又或者说，通用函数！</p>
<blockquote>
<p>声明以&lt;&gt;括号的T类型变量,以下这个函数叫做泛型</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> i1 = identity&lt;number&gt;(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> i2 = identity&lt;string&gt;(<span class="string">'1'</span>)</span><br><span class="line"><span class="keyword">var</span> i3 = identity(<span class="number">2</span>) <span class="comment">//在不定义类型时，编译器可以自动推断类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> i1,<span class="keyword">typeof</span> i2) <span class="comment">// number string number</span></span><br></pre></td></tr></table></figure>
<p>使用泛型变量</p>
<p>接下来，我们来试图获取传入参数的<code>length</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length)</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line">identity(<span class="number">1</span>) <span class="comment">//error TS2339: Property 'length' does not exist on type 'T'.</span></span><br></pre></td></tr></table></figure>
<p>上面是错误的写法，使用泛型函数，编译器要求你正确的使用这个通用的类型，简单地讲在没有使用泛型时，你必须把它当作是任意或所有类型，如果还是想打印出<code>length</code>，我们可以这样做</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function identity&lt;T&gt;(arg: Array&lt;T&gt;): T[] &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length)</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line">identity([<span class="number">1</span>]) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>泛型类型</p>
<p>泛型函数的类型与非泛型函数没什么不同，只是有一个类型参数在最前面，就像函数声明一样</p>
<blockquote>
<p>书写完整类型时，可以使用不同的类型变量名，只需在数量和使用方式上对应即可</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>):<span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIndentity: <span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span>(arg: T) =&gt; T = identity</span></span><br></pre></td></tr></table></figure>
<p> 我们还可以使用带有<strong>调用签名</strong>的对象字面量来定义泛型函数 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: &#123;&lt;T&gt;(arg: T): T&#125; = identity</span><br></pre></td></tr></table></figure>
<p>乍一看，这签名不就是类似个接口吗?</p>
<p>于是我们稍加改造，改造成接口的形式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface GenericFn &#123;</span><br><span class="line">    &lt;T&gt;<span class="function">(<span class="params">arg: T</span>) =&gt;</span> T</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: GenericFn = identity</span><br></pre></td></tr></table></figure>
<p>官方还提供了一个相似的例子</p>
<p>“把泛型的类型变量当作接口的一个参数，借此让接口的其他成员知道这个参数的类型”</p>
<p>如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface GenericFn&lt;T&gt; &#123;</span><br><span class="line">    (arg: T): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>):<span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myIndentity: GenericFn&lt;number&gt; = identity</span><br></pre></td></tr></table></figure>
<p>这种写法，我咋一看觉得十分奇怪，但是这也让<code>GenericFn</code>不再只描述泛型函数，也可以用于描述非泛型函数，什么意思呢？对上面的例子再次改造</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface GenericFn&lt;T&gt; &#123;</span><br><span class="line">    (arg: T): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">arg: number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myIndentity: GenericFn&lt;number&gt; = identity</span><br></pre></td></tr></table></figure>
<p>编译成功！这种的写法可以让接口同时可以描述泛型函数和非泛型函数，非常灵活！</p>
<p>泛型类</p>
<blockquote>
<p>泛型类的写法与泛型接口形似</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericFn</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    value: T</span><br><span class="line">    fn: <span class="function">(<span class="params">x:T,y:T</span>) =&gt;</span> T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGeneric = <span class="keyword">new</span> GenericFn &lt;number&gt; ()</span><br><span class="line">myGeneric.value = <span class="number">0</span></span><br><span class="line">myGeneric.fn = <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>) </span>&#123; <span class="keyword">return</span> x+y &#125;</span><br></pre></td></tr></table></figure>
<p>这种写法与上面的泛型接口有异曲同工之秒，可以肆意变换类型！</p>
<p>泛型的约束</p>
<p>泛型的约束旨在限制函数去处理传入的参数类型，比如，现在我们需要处理<code>.length</code>属性，前面的例子给出的答案是将泛型的类型变量变成数组的形式，如下所示</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function identity&lt;T&gt;(arg: Array&lt;T&gt;): T[] &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length)</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用Array或[]，可以让我们使用<code>.length</code>属性，但是这种方法，不是最好的，我们都只到<code>.length</code>属性是字符串才拥有的方法，那么我们能不能一开始，就约束传入的参数类型?可以用<code>extends</code>来实现约束传入的参数必须包含<code>length</code>属性，这自然也就排除了其他类型，只允许接收字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Length  &#123;</span><br><span class="line">    length: number</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Length</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length)</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error TS2345: Argument of type '3' is not assignable to parameter of type 'Length'</span></span><br><span class="line">identity(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>注意事项</p>
<p>1、计算符号是无法在泛型中使用的         </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error TS2365: Operator '+' cannot be applied to types 'T' and '1'.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、我们可以创建泛型接口、泛型类，但是无法创建泛型枚举和泛型命名空间</p>
<p>3、类的静态属性不能使用泛型</p>
<p>参考</p>
<p> <a href="https://jkchao.github.io/typescript-book-chinese/typings/neverType.html#%E7%94%A8%E4%BE%8B%EF%BC%9A%E8%AF%A6%E7%BB%86%E7%9A%84%E6%A3%80%E6%9F%A5" target="_blank" rel="noopener">深入理解TypeScript</a></p>
<p><a href="https://typescript.bootcss.com/functions.html" target="_blank" rel="noopener">Typescript中文手册</a></p>

      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/前端/" rel="tag"># 前端</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/30/React小结/" rel="next" title="React小结">
                <i class="fa fa-chevron-left"></i> React小结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/26/【每日一问】this究竟指向哪里/" rel="prev" title="【每日一问】this究竟指向哪里">
                【每日一问】this究竟指向哪里 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">罗锦旭</p>
              <p class="site-description motion-element" itemprop="description">记录学习过程是琐碎且费力的，但知识的留存会比以往更为长久</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">39</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本类型"><span class="nav-number">1.</span> <span class="nav-text">基本类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型"><span class="nav-number">1.1.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扩展"><span class="nav-number">1.2.</span> <span class="nav-text">扩展</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量声明"><span class="nav-number">2.</span> <span class="nav-text">变量声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解构"><span class="nav-number">3.</span> <span class="nav-text">解构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口"><span class="nav-number">4.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类"><span class="nav-number">5.</span> <span class="nav-text">类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数"><span class="nav-number">6.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型"><span class="nav-number">7.</span> <span class="nav-text">泛型</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">罗锦旭</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
      
  
  <script type="text/javascript" color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
